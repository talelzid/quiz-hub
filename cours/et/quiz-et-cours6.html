<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Quiz - Élaboration des tests</title>
    <link rel="stylesheet" href="../../css/style.css">
</head>
<body>
    <div class="global-course-title">Élaboration des tests</div>
    <h1>Quiz : Les scénarios de tests (Cours 6)</h1>
    
    <div class="progress-container">
        <div class="progress-info">
            <span id="question-counter">Question 1 / 10</span>
            <div class="progress-stats">
                <span class="stat-badge incorrect"><span class="stat-icon">✕</span><span id="incorrect-count">0</span></span>
                <span class="stat-badge correct"><span class="stat-icon">✓</span><span id="correct-count">0</span></span>
            </div>
        </div>
        <div class="progress-bar-wrapper" id="progressBar"></div>
    </div>
    
    <div id="quiz-container" class="card"></div>
    
    <div id="feedback" class="feedback-container"></div>
    
    <div class="quiz-navigation">
        <button id="prevBtn" onclick="previousQuestion()">← Précédent</button>
        <button id="nextBtn" onclick="nextQuestion()">Suivant →</button>
    </div>
    
    <div id="result"></div>

    <script>
        const questions = [
            {
                q: "Quelle est la principale différence entre un scénario de test et un cas de test dans une approche moderne ?",
                options: [
                    { text: "Le scénario décrit l'intention logique alors que le cas de test est l'instanciation avec des données précises.", explain: "" },
                    { text: "Le scénario est écrit par le développeur et le cas de test par le QA.", explain: "Les deux sont généralement sous la responsabilité de l'équipe qualité ou rédigés de manière collaborative." },
                    { text: "Il n'y a aucune différence, ce sont deux synonymes exacts.", explain: "Dans un outil de gestion de tests, on distingue l'actif de test (le ticket) de son exécution (le run)." },
                    { text: "Le scénario est obligatoire dans Jira, mais pas le cas de test.", explain: "Les deux concepts sont nécessaires pour assurer une exécution et une traçabilité rigoureuse." }
                ],
                correct: 0,
                correctExplain: "Le scénario est une 'coquille' descriptive (le quoi) alors que le cas de test correspond à une exécution concrète (le comment) sur un environnement donné avec des jeux de données."
            },
            {
                q: "Dans Jira, quel type de lien est généralement utilisé pour lier un Test à une User Story afin de calculer la couverture ?",
                options: [
                    { text: "Relates to", explain: "Ce lien est trop générique et n'est pas comptabilisé par les outils comme Xray ou Zephyr pour la couverture." },
                    { text: "Is tested by / Tests", explain: "" },
                    { text: "Blocks", explain: "Ce lien est utilisé lorsqu'un ticket empêche l'avancement d'un autre, généralement pour des bugs bloquants." },
                    { text: "Clones", explain: "Le clonage crée une copie identique mais n'établit pas de relation de vérification fonctionnelle." }
                ],
                correct: 1,
                correctExplain: "C'est le lien sémantique standard qui permet aux outils de reporting de lier l'exigence au résultat de validation pour générer la matrice de couverture."
            },
            {
                q: "Qu'est-ce qu'un scénario de type 'Nominal' ?",
                options: [
                    { text: "Un test qui vérifie uniquement les messages d'erreur.", explain: "Cela correspondrait plutôt à un scénario d'exception." },
                    { text: "Un parcours où l'utilisateur suit le flux principal sans erreur (Happy Path).", explain: "" },
                    { text: "Un test qui ne contient pas de données de test.", explain: "Tout test exécutable nécessite des données, quel que soit son type." },
                    { text: "Un test nommé par l'identifiant unique de Jira.", explain: "Le nommage est une règle de rédaction, pas une typologie de parcours." }
                ],
                correct: 1,
                correctExplain: "Le scénario nominal (ou Happy Path) valide que la fonctionnalité répond au besoin de base pour lequel elle a été conçue sans rencontrer d'obstacles."
            },
            {
                q: "Pourquoi la section 'Post-conditions' est-elle cruciale lors de l'exécution d'une suite de tests ?",
                options: [
                    { text: "Elle permet de rédiger le rapport de test final.", explain: "Le rapport est une synthèse globale, pas une étape technique de nettoyage." },
                    { text: "Elle garantit que l'environnement est nettoyé pour éviter que les traces d'un test ne fassent échouer le suivant.", explain: "" },
                    { text: "Elle sert à définir le mot de passe de l'utilisateur.", explain: "La définition des accès se situe normalement dans les pré-conditions." },
                    { text: "Elle est optionnelle et ne sert qu'à l'automatisation.", explain: "Même en test manuel, le nettoyage est indispensable pour la reproductibilité." }
                ],
                correct: 1,
                correctExplain: "L'isolation des tests prévient les 'faux négatifs' causés par des données polluantes restées en base de données après un test précédent."
            },
            {
                q: "Lors de la transformation d'un critère d'acceptation Gherkin 'Etant donné (Given)' en test Jira, où place-t-on généralement cette information ?",
                options: [
                    { text: "Dans le résumé (Summary).", explain: "Le résumé doit être court ; le 'Given' est souvent trop détaillé pour cela." },
                    { text: "Dans les pré-conditions.", explain: "" },
                    { text: "Dans le résultat attendu de la dernière étape.", explain: "Le résultat attendu correspond au 'Then' du Gherkin." },
                    { text: "Dans les commentaires du ticket.", explain: "Les éléments structurants du test doivent être dans des champs dédiés." }
                ],
                correct: 1,
                correctExplain: "Le 'Given' définit l'état initial requis du système, ce qui correspond exactement au rôle des pré-conditions dans un cas de test."
            },
            {
                q: "Que signifie une User Story avec le statut de couverture 'UNCOVERED' ?",
                options: [
                    { text: "Qu'aucun test n'a encore été créé ou lié pour vérifier cette exigence.", explain: "" },
                    { text: "Que le développeur n'a pas fini de coder l'US.", explain: "Le statut de couverture concerne les tests, pas l'avancement du développement." },
                    { text: "Que les tests ont été exécutés mais ont échoué.", explain: "Dans ce cas, le statut de couverture serait 'FAILED'." },
                    { text: "Que l'US est trop complexe pour être testée.", explain: "Toute US doit pouvoir être testée ; 'Uncovered' est un manque d'association." }
                ],
                correct: 0,
                correctExplain: "Cela indique un risque majeur de qualité : l'exigence existe dans le backlog mais aucun test n'a été conçu pour la valider."
            },
            {
                q: "Quelle est la règle d'or pour la rédaction des étapes (Steps) d'un test ?",
                options: [
                    { text: "Chaque étape doit comporter plusieurs actions pour gagner du temps.", explain: "Cela rend le test difficile à suivre et l'origine de l'échec difficile à diagnostiquer." },
                    { text: "Chaque étape doit être atomique : une action précise pour un résultat attendu précis.", explain: "" },
                    { text: "Il ne faut jamais mettre de données de test dans les étapes.", explain: "Au contraire, les valeurs limites ou spécifiques doivent être mentionnées pour guider l'exécuteur." },
                    { text: "Les étapes doivent être rédigées uniquement en anglais.", explain: "La langue dépend des conventions de l'équipe et du projet." }
                ],
                correct: 1,
                correctExplain: "L'atomicité permet une précision maximale lors du passage du test : si l'étape échoue, on sait exactement quelle action a posé problème."
            },
            {
                q: "Dans Jira, quelle est l'utilité principale des 'Labels' pour un QA ?",
                options: [
                    { text: "Remplacer les liens vers les User Stories.", explain: "Les labels ne permettent pas de calculer la couverture structurelle des exigences." },
                    { text: "Organiser des suites de tests dynamiques (ex: Smoke_Test, Regression).", explain: "" },
                    { text: "Définir qui est responsable du test.", explain: "Le champ 'Assignee' est réservé à cet usage." },
                    { text: "Indiquer le temps passé sur le test.", explain: "Le 'Log Work' est utilisé pour le suivi du temps." }
                ],
                correct: 1,
                correctExplain: "Les labels sont des marqueurs flexibles qui permettent de filtrer et de sélectionner rapidement des tests pour des campagnes spécifiques (ex: Sanity Check)."
            },
            {
                q: "Qu'est-ce qu'un critère de succès (ou critère d'évaluation) dans un scénario ?",
                options: [
                    { text: "Le nom du testeur qui a réussi le test.", explain: "C'est une métadonnée d'exécution, pas un critère de qualité." },
                    { text: "La validation globale que l'objectif du scénario est atteint et le système est dans l'état final attendu.", explain: "" },
                    { text: "Le temps de réponse du serveur uniquement.", explain: "C'est un critère de performance, pas forcément le critère de succès fonctionnel." },
                    { text: "Une liste de tous les bugs trouvés pendant le test.", explain: "Le succès se définit par l'atteinte de l'objectif, pas par la liste des échecs." }
                ],
                correct: 1,
                correctExplain: "Le critère de succès est la condition finale qui permet de dire si l'exigence métier est satisfaite à la fin du parcours."
            },
            {
                q: "Un scénario 'Alternatif' est défini par :",
                options: [
                    { text: "L'utilisation d'un chemin différent pour atteindre le même but fonctionnel.", explain: "" },
                    { text: "Une erreur système majeure qui arrête le test.", explain: "Cela correspond à un scénario d'exception ou à un blocage." },
                    { text: "Le fait de tester sur un autre navigateur que Chrome.", explain: "C'est une variation d'environnement, pas une variante de flux fonctionnel." },
                    { text: "Un test qui n'est pas lié à une User Story.", explain: "L'absence de lien est une erreur de traçabilité, pas un type de scénario." }
                ],
                correct: 0,
                correctExplain: "Un scénario alternatif explore une variante valide du flux (ex: payer par carte au lieu de virement). Le but est atteint, mais par un chemin différent."
            }
        ];

        let currentQuestion = 0;
        let answers = new Array(questions.length).fill(null);
        let answered = new Array(questions.length).fill(false);

        function displayQuestion() {
            const container = document.getElementById('quiz-container');
            const item = questions[currentQuestion];
            
            let html = `<div class="question">${currentQuestion + 1}. ${item.q}</div>`;
            const letters = ['A', 'B', 'C', 'D'];
            item.options.forEach((opt, i) => {
                let classes = '';
                if (answers[currentQuestion] === i) {
                    classes = 'selected ';
                    if (i === item.correct) {
                        classes += 'correct';
                    } else {
                        classes += 'incorrect';
                    }
                }
                const disabledClass = answered[currentQuestion] ? 'disabled' : '';
                html += `<div class="option ${classes} ${disabledClass}" onclick="${answered[currentQuestion] ? '' : `handleAnswerClick(${i})`}" style="${answered[currentQuestion] ? 'cursor: not-allowed;' : ''}"><span class="option-letter">${letters[i]}</span> ${opt.text}</div>`;
            });
            
            container.innerHTML = html;
            
            if (answered[currentQuestion]) {
                showFeedback();
            } else {
                document.getElementById('feedback').innerHTML = '';
                document.getElementById('feedback').classList.remove('show');
            }
            
            updateProgressBar();
            updateNavigationButtons();
            updateProgressInfo();
        }

        function handleAnswerClick(index) {
            if (answered[currentQuestion]) return;
            
            answers[currentQuestion] = index;
            answered[currentQuestion] = true;
            
            showFeedback();
            updateProgressBar();
            updateProgressInfo();
            updateNavigationButtons();
            displayQuestion();
        }

        function showFeedback() {
            const feedbackDiv = document.getElementById('feedback');
            const item = questions[currentQuestion];
            const isCorrect = answers[currentQuestion] === item.correct;
            const selectedOption = item.options[answers[currentQuestion]];
            
            feedbackDiv.className = 'feedback-container show ' + (isCorrect ? 'feedback-correct' : 'feedback-incorrect');
            
            let html = '';
            
            if (isCorrect) {
                html += `
                    <div class="feedback-header">Bonne réponse!</div>
                    <div class="feedback-explanation">${item.correctExplain}</div>
                `;
            } else {
                html += `
                    <div class="feedback-header">Pas tout à fait</div>
                    <div class="feedback-explanation">${selectedOption.explain}</div>
                    <div class="correct-answer-box">
                        <div class="correct-answer-label">✓ Bonne réponse:</div>
                        <div>${item.options[item.correct].text}</div>
                        <div style="margin-top: 8px; font-size: 0.9em;">${item.correctExplain}</div>
                    </div>
                `;
            }
            
            feedbackDiv.innerHTML = html;
        }

        function updateProgressBar() {
            const progressBar = document.getElementById('progressBar');
            progressBar.innerHTML = '';
            
            for (let i = 0; i < questions.length; i++) {
                const segment = document.createElement('div');
                segment.className = 'progress-segment';
                
                if (!answered[i]) {
                    segment.classList.add('unanswered');
                } else if (answers[i] === questions[i].correct) {
                    segment.classList.add('correct');
                } else {
                    segment.classList.add('incorrect');
                }
                
                progressBar.appendChild(segment);
            }
        }

        function updateNavigationButtons() {
            const isAnswered = answered[currentQuestion];
            document.getElementById('prevBtn').disabled = currentQuestion === 0 || !isAnswered;
            document.getElementById('nextBtn').disabled = !isAnswered;
            
            if (currentQuestion === questions.length - 1) {
                document.getElementById('nextBtn').textContent = 'Voir Résultat';
            } else {
                document.getElementById('nextBtn').textContent = 'Suivant →';
            }
        }

        function updateProgressInfo() {
            document.getElementById('question-counter').textContent = `Question ${currentQuestion + 1} / ${questions.length}`;
            
            let correctCount = 0;
            let incorrectCount = 0;
            
            for (let i = 0; i < answers.length; i++) {
                if (answered[i]) {
                    if (answers[i] === questions[i].correct) {
                        correctCount++;
                    } else {
                        incorrectCount++;
                    }
                }
            }
            
            document.getElementById('correct-count').textContent = correctCount;
            document.getElementById('incorrect-count').textContent = incorrectCount;
        }

        function nextQuestion() {
            if (currentQuestion === questions.length - 1) {
                showFinalResults();
                return;
            }
            
            currentQuestion++;
            displayQuestion();
        }

        function previousQuestion() {
            if (currentQuestion > 0) {
                currentQuestion--;
                displayQuestion();
            }
        }

        function showFinalResults() {
            let score = 0;
            answers.forEach((answer, index) => {
                if (answer === questions[index].correct) score++;
            });
            
            const container = document.getElementById('quiz-container');
            container.innerHTML = '<div class="question">Quiz terminé!</div>';
            
            const feedbackDiv = document.getElementById('feedback');
            feedbackDiv.className = 'feedback-container';
            feedbackDiv.innerHTML = '';
            
            let recapHtml = '<div class="recap-title">Résumé de vos réponses</div>';
            
            questions.forEach((question, index) => {
                const userAnswer = question.options[answers[index]];
                const correctAnswer = question.options[question.correct];
                const isCorrect = answers[index] === question.correct;
                
                recapHtml += `
                    <div class="recap-card ${isCorrect ? 'correct' : 'incorrect'}">
                        <div class="recap-number">Question ${index + 1} / ${questions.length}</div>
                        <div class="recap-question">${question.q}</div>
                        <div class="recap-answer-item user">
                            <span class="recap-label">Votre réponse:</span>
                            ${userAnswer.text}
                            <span class="recap-result ${isCorrect ? 'correct' : 'incorrect'}">
                                ${isCorrect ? '✓ Correct' : '✗ Incorrect'}
                            </span>
                        </div>
                        ${!isCorrect ? `
                            <div class="recap-answer-item correct-answer">
                                <span class="recap-label">Bonne réponse:</span>
                                ${correctAnswer.text}
                            </div>
                        ` : ''}
                    </div>
                `;
            });
            
            document.getElementById('result').innerHTML = `
                <div style="font-size: 2em; margin: 30px 0 20px;">Votre score : ${score} / ${questions.length}</div>
                <div style="font-size: 1.1em; color: #555; margin-bottom: 30px;">Réussite : ${Math.round(score / questions.length * 100)}%</div>
                <div class="recap-container">${recapHtml}</div>
            `;
            
            document.getElementById('prevBtn').disabled = false;
            document.getElementById('nextBtn').textContent = 'Recommencer';
            document.getElementById('nextBtn').disabled = false;
            document.getElementById('nextBtn').onclick = function() { location.reload(); };
            document.getElementById('prevBtn').onclick = function() {
                currentQuestion = questions.length - 1;
                displayQuestion();
            };
        }

        displayQuestion();
    </script>
</body>
</html>